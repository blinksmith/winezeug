/* Execute a command with a given timeout, in seconds */
/* Why isn't a command like this included by default in Unix? */
/* Public domain, Dan Kegel, 2008 */

#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <sys/file.h>
#include <sys/types.h>
#include <sys/wait.h>

pid_t child_pid;

void handler(int x)
{
    fprintf(stderr, "Timeout!  Killing child.\n");
    /* TODO: This probably won't kill grandchildren.  Do we want to create a process group? */
    kill(child_pid, SIGKILL);
    exit(1);
}

/* a real implementation would not have a limit on commandline length */
#define MAXARGS 1000

/* Extract test id (module:filename) from commandline, return true if ok */
int getTestID(int argc, char **argv, char *buf)
{
    int i;
    const char *module, *module_end;
    const char *file, *file_end;
    char *p = buf;

    module = argv[1];
    if (!module) return 0;
    module_end = strrchr(module, '_');
    if (!module_end) return 0;

    file = argv[2];
    if (!file) return 0;
    file_end = strrchr(file, '.');
    if (!file_end) return 0;

    while (module != module_end)
      *p++ = *module++;
    *p++ = ':';
    while (file != file_end)
      *p++ = *file++;
    *p = 0;
    return 1;
}

/*
 * Whitelist generated by doing "make -j50 -k test" and then
 *  find dlls -name '*.ok' | sort | sed 's,dlls/,,;s,/tests/,:,;s,.ok$,,;s/^/"/;s/$/",/'
 * TODO: Update it as we learn about the test suite, and as it changes.
 */
static const char *whitelist[] = {
    "advapi32:cred",
    "advapi32:crypt",
    "advapi32:crypt_lmhash",
    "advapi32:crypt_md4",
    "advapi32:crypt_md5",
    "advapi32:crypt_sha",
    "advapi32:lsa",
    "advapi32:registry",
    "advapi32:security",
    "advapi32:service",
    "advpack:advpack",
    "advpack:files",
    "advpack:install",
    "browseui:autocomplete",
    "comcat:comcat",
    "comctl32:comboex",
    "comctl32:datetime",
    "comctl32:dpa",
    "comctl32:header",
    "comctl32:imagelist",
    "comctl32:listview",
    "comctl32:misc",
    "comctl32:monthcal",
    "comctl32:mru",
    "comctl32:progress",
    "comctl32:propsheet",
    "comctl32:subclass",
    "comctl32:tab",
    "comctl32:trackbar",
    "comctl32:treeview",
    "comctl32:updown",
    "comdlg32:filedlg",
    "comdlg32:printdlg",
    "credui:credui",
    "crypt32:base64",
    "crypt32:cert",
    "crypt32:chain",
    "crypt32:crl",
    "crypt32:ctl",
    "crypt32:encode",
    "crypt32:main",
    "crypt32:message",
    "crypt32:oid",
    "crypt32:protectdata",
    "crypt32:sip",
    "crypt32:store",
    "crypt32:str",
    "cryptnet:cryptnet",
    "cryptui:cryptui",
    "d3drm:vector",
    "d3dx8:math",
    "d3dx9_36:math",
    "d3dxof:d3dxof",
    "dinput:device",
    "dinput:joystick",
    "dinput:keyboard",
    "dnsapi:name",
    "dnsapi:record",
    "dplayx:dplayx",
    "dsound:capture",
    "dsound:ds3d",
    "dsound:ds3d8",
    "dsound:dsound",
    "dsound:dsound8",
    "dsound:duplex",
    "dsound:propset",
    "fusion:asmcache",
    "fusion:asmname",
    "fusion:fusion",
    "gdi32:bitmap",
    "gdi32:brush",
    "gdi32:clipping",
    "gdi32:dc",
    "gdi32:font",
    "gdi32:gdiobj",
    "gdi32:generated",
    "gdi32:icm",
    "gdi32:mapping",
    "gdi32:metafile",
    "gdi32:palette",
    "gdi32:path",
    "gdi32:pen",
    "gdiplus:brush",
    "gdiplus:customlinecap",
    "gdiplus:font",
    "gdiplus:graphics",
    "gdiplus:graphicspath",
    "gdiplus:image",
    "gdiplus:matrix",
    "gdiplus:pathiterator",
    "gdiplus:pen",
    "gdiplus:region",
    "gdiplus:stringformat",
    "hlink:hlink",
    "inetcomm:mimeintl",
    "inetcomm:mimeole",
    "inetmib1:main",
    "infosoft:infosoft",
    "iphlpapi:iphlpapi",
    "itss:protocol",
    "jscript:jscript",
    "jscript:run",
    "kernel32:actctx",
    "kernel32:alloc",
    "kernel32:atom",
    "kernel32:change",
    "kernel32:codepage",
    "kernel32:comm",
    "kernel32:console",
    "kernel32:debugger",
    "kernel32:directory",
    "kernel32:drive",
    "kernel32:environ",
    "kernel32:file",
    "kernel32:format_msg",
    "kernel32:generated",
    "kernel32:heap",
    "kernel32:loader",
    "kernel32:locale",
    "kernel32:mailslot",
    "kernel32:module",
    "kernel32:path",
    "kernel32:pipe",
    "kernel32:process",
    "kernel32:profile",
    "kernel32:resource",
    "kernel32:sync",
    "kernel32:thread",
    "kernel32:time",
    "kernel32:timer",
    "kernel32:toolhelp",
    "kernel32:version",
    "kernel32:virtual",
    "kernel32:volume",
    "localspl:localmon",
    "localui:localui",
    "lz32:lzexpand_main",
    "mapi32:imalloc",
    "mapi32:prop",
    "mapi32:util",
    "mlang:mlang",
    "msacm32:msacm",
    "mscms:profile",
    "mshtml:htmldoc",
    "mshtml:misc",
    "mshtml:protocol",
    "msi:automation",
    "msi:record",
    "msi:source",
    "mstask:task",
    "mstask:task_scheduler",
    "mstask:task_trigger",
    "msvcrt:cpp",
    "msvcrt:data",
    "msvcrtd:debug",
    "msvcrt:dir",
    "msvcrt:environ",
    "msvcrt:file",
    "msvcrt:headers",
    "msvcrt:heap",
    "msvcrt:printf",
    "msvcrt:scanf",
    "msvcrt:string",
    "msvcrt:time",
    "msxml3:domdoc",
    "msxml3:saxreader",
    "msxml3:schema",
    "msxml3:xmldoc",
    "msxml3:xmlelem",
    "netapi32:access",
    "netapi32:apibuf",
    "netapi32:ds",
    "netapi32:wksta",
    "ntdll:atom",
    "ntdll:change",
    "ntdll:env",
    "ntdll:error",
    "ntdll:exception",
    "ntdll:file",
    "ntdll:generated",
    "ntdll:info",
    "ntdll:large_int",
    "ntdll:om",
    "ntdll:path",
    "ntdll:port",
    "ntdll:reg",
    "ntdll:rtl",
    "ntdll:rtlbitmap",
    "ntdll:rtlstr",
    "ntdll:string",
    "ntdll:time",
    "ntdsapi:ntdsapi",
    "ntprint:ntprint",
    "odbccp32:misc",
    "ole32:clipboard",
    "ole32:compobj",
    "ole32:defaulthandler",
    "ole32:dragdrop",
    "ole32:errorinfo",
    "ole32:hglobalstream",
    "ole32:marshal",
    "ole32:moniker",
    "ole32:ole2",
    "ole32:propvariant",
    "ole32:stg_prop",
    "ole32:storage32",
    "ole32:usrmarshal",
    "oleacc:main",
    "oleaut32:olefont",
    "oleaut32:olepicture",
    "oleaut32:safearray",
    "oleaut32:tmarshal",
    "oleaut32:typelib",
    "oleaut32:usrmarshal",
    "oleaut32:varformat",
    "oleaut32:vartest",
    "oleaut32:vartype",
    "opengl32:opengl",
    "pdh:pdh",
    "psapi:psapi_main",
    "qedit:mediadet",
    "qmgr:enum_files",
    "qmgr:enum_jobs",
    "qmgr:file",
    "qmgr:job",
    "quartz:avisplitter",
    "quartz:filtergraph",
    "quartz:filtermapper",
    "quartz:memallocator",
    "quartz:misc",
    "quartz:referenceclock",
    "quartz:videorenderer",
    "rasapi32:rasapi",
    "riched20:richole",
    "riched32:editor",
    "rpcrt4:cstub",
    "rpcrt4:generated",
    "rpcrt4:ndr_marshall",
    "rpcrt4:rpc_async",
    "rpcrt4:server",
    "rsaenh:rsaenh",
    "schannel:main",
    "secur32:main",
    "secur32:ntlm",
    "secur32:schannel",
    "secur32:secur32",
    "serialui:confdlg",
    "setupapi:devinst",
    "setupapi:install",
    "setupapi:misc",
    "setupapi:parser",
    "setupapi:query",
    "setupapi:stringtable",
    "shdocvw:intshcut",
    "shdocvw:shdocvw",
    "shdocvw:shortcut",
    "shdocvw:webbrowser",
    "shell32:generated",
    "shell32:shelllink",
    "shell32:shellpath",
    "shell32:shfldr_special",
    "shell32:shlfileop",
    "shell32:shlfolder",
    "shell32:string",
    "shell32:systray",
    "shlwapi:assoc",
    "shlwapi:clist",
    "shlwapi:clsid",
    "shlwapi:generated",
    "shlwapi:istream",
    "shlwapi:ordinal",
    "shlwapi:path",
    "shlwapi:shreg",
    "shlwapi:string",
    "shlwapi:url",
    "snmpapi:util",
    "spoolss:spoolss",
    "urlmon:generated",
    "urlmon:misc",
    "urlmon:stream",
    "user32:class",
    "user32:combo",
    "user32:cursoricon",
    "user32:dce",
    "user32:dialog",
    "user32:edit",
    "user32:generated",
    "user32:listbox",
    "user32:monitor",
    "user32:resource",
    "user32:scroll",
    "user32:static",
    "user32:text",
    "user32:winstation",
    "user32:wsprintf",
    "userenv:userenv",
    "usp10:usp10",
    "uxtheme:system",
    "version:info",
    "version:install",
    "winhttp:notification",
    "winhttp:url",
    "winhttp:winhttp",
    "wininet:generated",
    "wininet:http",
    "wininet:internet",
    "wininet:url",
    "wininet:urlcache",
    "winmm:capture",
    "winmm:mci",
    "winmm:mixer",
    "winmm:mmio",
    "winmm:timer",
    "winmm:wave",
    "winspool.drv:info",
    "wintrust:asn",
    "wintrust:crypt",
    "wintrust:register",
    "wintrust:softpub",
    "wldap32:parse",
    "ws2_32:protocol",
    "ws2_32:sock",
};
const size_t whitelist_len = sizeof(whitelist) / sizeof(whitelist[0]);

/* this isn't quite legal, but it works */
int mystrcmp(const char *a, const char **bp)
{
    const char *b = *bp;
    return strcmp(a, b);
}

static int inWhitelist(const char *testid)
{
    typedef int (*compar)(const void *, const void *);

    return bsearch(testid, whitelist, whitelist_len, 
         sizeof(whitelist[0]), (compar)mystrcmp) != NULL;
}

int main(int argc, char **argv)
{
    char *newargv[MAXARGS];
    int timeout;
    pid_t pid;
    int i;
    int waitresult;
    int ret;
    char testid[64];
    int lockfd;

    if (argc < 3) {
        fprintf(stderr, "Usage: alarm timeout-in-seconds command ...\n");
        exit(1);
    }
    timeout = atoi(argv[1]);
    if (timeout < 1) {
        fprintf(stderr, "Timeout must be positive, was %s\n", argv[1]);
        exit(1);
    }

    for (i=0; i<argc-2 && i<MAXARGS-1; i++)
        newargv[i] = argv[i+2];
    newargv[i] = NULL;

    lockfd = -1;
    if (getTestID(i, newargv, testid) || !inWhitelist(testid)) {
        /* Can't run in parallel, so let's get a lock file */
        lockfd = open("alarm.lock", O_RDWR|O_CREAT, 0600);

        /* FIXME: set screen back to default resolution,
         * since some tests don't clean up after themselves there
         */
        system("xrandr -s 0");
    }

    if (lockfd != -1) 
        flock(lockfd, LOCK_EX);

    child_pid = fork();
    if (child_pid == 0) {
        /* child */
        /* TODO: Do we want to make this its own process group for ease of killing grandchildren? */
        execvp(newargv[0], newargv);
        /* notreached */
        perror(newargv[0]);
        exit(1);
    }

    signal(SIGALRM, handler);
    alarm(timeout);
    waitresult = 0;
    /* Probably don't need this loop, but maybe ^Z could interrupt wait */
    while ((ret = wait(&waitresult)) == -1 && errno == EINTR)
        ;
    if (lockfd != -1)
        flock(lockfd, LOCK_UN);
    if (!WIFEXITED(waitresult)) {
        printf("Terminated abnormally\n");
        exit(99);
    }
    exit(WEXITSTATUS(waitresult));
}
